# Радар деэскалации в чатах: Конечные автоматы и LTLf-валидация

Этот проект представляет собой учебную реализацию **"Радара деэскалации"** для текстовых диалогов. Его ключевая особенность — использование классических формальных методов (конечные автоматы, темпоральная логика) вместо статистических моделей машинного обучения. Это обеспечивает 100% объяснимость, предсказуемость и высокую скорость работы.

Система анализирует сообщения в режиме реального времени, отслеживает "эмоциональное состояние" диалога и проверяет его историю на соответствие заранее заданным "нормам поведения".

## Ключевые идеи

*   **"Стеклянный ящик" вместо "черного":** Каждое решение системы можно проследить до конкретного правила в конфигурационном файле.
*   **Гибридная модель состояний:** Динамика диалога управляется двумя механизмами:
    1.  **Детерминированный конечный автомат (DFA):** Мгновенно реагирует на негативные или позитивные события в сообщениях.
    2.  **Модель "остывания" (`CoolingManager`):** Постепенно снижает уровень напряженности, если в диалоге наступает "затишье".
*   **Верификация поведения во времени:** **Линейная темпоральная логика на конечных трассах (LTLf)** используется для проверки сложных свойств всей истории диалога (например, "после обвинения в течение 4 шагов должно последовать извинение").
*   **Декларативное управление:** Вся логика — триггеры, состояния, переходы, LTLf-правила и тексты подсказок — находится в одном YAML-файле (`config/rules.yaml`) и может быть изменена без правок кода.

## Архитектура

Система состоит из следующих ключевых компонентов:

1.  **Интерфейс (`telegram_bot.py`):** Принимает сообщения из Telegram (включая Telegram Business API) и передает их ядру.
2.  **Ядро/Оркестратор (`engine.py`):** Класс `RulesEngine`, который управляет всем пайплайном обработки.
3.  **Конфигурация (`config/rules.yaml`):** Единый источник правды для всей логики.
4.  **Компоненты анализа:**
    *   **`triggers.py` (`TriggerMatcher`):** С помощью регулярных выражений извлекает из текста атомарные **события** (например, `INSULT`, `APOLOGY`).
    *   **`dfa.py` (`DFAEngine`):** Реализует логику конечного автомата, предлагая новое состояние на основе событий. Имеет встроенный приоритет на эскалирующие события.
    *   **`cooling.py` (`CoolingManager`):** Реализует логику "остывания" диалога при отсутствии событий.
    *   **`ltlf.py`:** Полностью своя реализация парсера и интерпретатора LTLf для проверки темпоральных свойств на конечных трассах.
    *   **`risk.py` (`RiskMeter`):** Вычисляет числовую метрику "риска" диалога.
    *   **`hints.py` (`pick_hints`):** Подбирает и форматирует контекстные подсказки для пользователя.

## Быстрый старт

### 1. Установка

Для запуска проекта вам понадобится Python 3.9+.

```bash
# 1. Клонируйте репозиторий
git clone <URL вашего репозитория>
cd <папка проекта>

# 2. Создайте и активируйте виртуальное окружение
python -m venv .venv
source .venv/bin/activate  # для Linux/macOS
# .\.venv\Scripts\Activate.ps1  # для Windows PowerShell

# 3. Установите зависимости
python -m pip install --upgrade pip
pip install -r requirements.txt
```

### 2. Запуск CLI-версии

CLI-режим позволяет протестировать ядро системы на текстовом файле с диалогом.

```bash
# Запустите CLI, указав путь к конфигу и файлу с диалогом
python -m src.cli.run_cli --config config/rules.yaml --transcript sample_data/transcript.txt
```

Вы увидите пошаговый анализ каждой реплики из файла.

### 3. Запуск Telegram-бота


1.  **Создайте бота:** Получите токен у @BotFather в Telegram.
2.  **Создайте файл `.env`:** Скопируйте `.env.example` в `.env` и впишите в него ваш токен.
    ```
    # .env
    TELEGRAM_BOT_TOKEN="123456:ABC-DeFgH..."
    
    # Укажите ваш Chat ID для рабоы в режиме "невидимого помощника"
    USER_CHAT_ID="987654321"
    ```
3.  **Запустите бота:**
    ```bash
    python -m src.telegram_bot
    ```

**Как использовать бота:**

*   **Telegram Business (Ghost Mode):**
    1.  В настройках вашего Telegram-аккаунта перейдите в `Settings → Telegram Business → Chatbots`.
    2.  Подключите вашего бота в качестве помощника.
    3.  Теперь, когда вы будете вести переписку в 1-на-1 чатах, бот будет автоматически получать копии сообщений, анализировать их и присылать **вам в личные сообщения** подробный отчет, не вмешиваясь в сам диалог.

## Теоретическая основа

Проект базируется на трех столпах теории алгоритмов:

1.  **Теория формальных языков:** Мы предполагаем, что языки триггеров (например, всех оскорблений) являются **регулярными**. Согласно **теореме Клини**, это означает, что их можно распознать с помощью **конечных автоматов**, что и реализует `TriggerMatcher` с помощью `regex`.

2.  **Теория автоматов:** Динамика состояний диалога моделируется **гибридной моделью**, ядром которой является **Детерминированный Конечный Автомат (DFA)**. Его определение `M = ⟨Q, Σ', δ, q₀, F⟩` напрямую отображается в секцию `dfa` файла `rules.yaml`.

3.  **Математическая логика:** Для проверки сложных свойств всей истории диалога мы используем **Линейную Темпоральную Логику на конечных трассах (LTLf)**. Наш собственный интерпретатор в `ltlf.py` реализует строгую математическую семантику операторов `G` (Globally), `F` (Finally), `X` (Next) и `U` (Until) для верификации "норм поведения".

## Структура проекта

```
.
├── config/
│   └── rules.yaml          # <-- ВСЯ ЛОГИКА ЗДЕСЬ
├── src/
│   ├── core/
│   │   ├── config.py       # Загрузка и типизация YAML
│   │   ├── cooling.py      # Логика "остывания"
│   │   ├── dfa.py          # Движок DFA
│   │   ├── engine.py       # Главный оркестратор
│   │   ├── hints.py        # Генерация подсказок
│   │   ├── ltlf.py         # Парсер и интерпретатор LTLf
│   │   ├── risk.py         # Расчет риска
│   │   └── triggers.py     # Извлечение событий
│   └── cli/
│       └── run_cli.py      # CLI-интерфейс
├── telegram_bot.py     # Telegram-интерфейс
├── requirements.txt
└── README.md
```


